\chapter{Day 2: Inventory Management System}

<<Day02.hs>>=
module AdventOfCode.Year2018.Day02
  ( main,
    partOne,
    partTwo,
  )
where

<<Imports>>

<<Types and parsers>>

<<Part One>>

<<Part Two>>

<<Define the main function>>
@

\section{Type aliases and parsers}

<<Types and parsers>>=
type BoxID = String

boxID :: Parser BoxID
boxID = some letter

type Checksum = Integer
@ %def BoxID
@ %def boxIDs

\section{Part One}

<<Part One>>=
checksum :: [BoxID] -> Checksum
checksum =
  fmap frequencies
    >>> filter (elem 2) &&& filter (elem 3)
    >>> length *** length
    >>> product
    >>> fromIntegral

@ %def checksum

<<Part One>>=
partOne :: [BoxID] -> Checksum
partOne = checksum
@ %def partOne

\section{Part Two}

<<Part Two>>=
correctBoxIDs :: [BoxID] -> Maybe (BoxID, BoxID)
correctBoxIDs = listToMaybe . mapMaybe go . tails
  where
    go (x : xs@(_ : _)) = (,) <$> pure x <*> find (hammingSimilar 1 x) xs
    go _ = Nothing

@ %def correctBoxIDs

<<Part Two>>=
partTwo :: [BoxID] -> Maybe String
partTwo = fmap (uncurry intersect) . correctBoxIDs
@ %def partTwo


\section{Main}

<<Define the main function>>=
main :: IO ()
main = do
  input <- parseInput (boxID `sepEndBy` newline) $(inputFilePath)
  putStr "Part One: "
  print (partOne input)
  putStr "Part Two: "
  putStrLn (fromMaybe "failed!" (partTwo input))
@


\section{Imports}

<<Imports>>=
import AdventOfCode.Input (parseInput)
import AdventOfCode.TH (inputFilePath)
import AdventOfCode.Util (frequencies, hammingSimilar)
import Control.Arrow ((&&&), (***), (>>>))
import Data.List (find, intersect, tails)
import Data.Maybe (fromMaybe, listToMaybe, mapMaybe)
import Text.Trifecta (Parser, letter, newline, sepEndBy, some)
@
